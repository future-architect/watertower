{
  "id": 1,
  "title": "プリミティブ型",
  "tags": [
    "basic", "syntax", "typescript"
  ],
  "content": "プリミティブ型\nプログラムの解説にはよく、リテラルという言葉がでてきます。 リテラルというのは、ソースコード中に直接記述できるデータのことです。TypeScriptには何種類かあります。\n\nboolean 型\n\nnumber 型\n\nstring 型\n\n配列\n\nオブジェクト\n\n関数\n\nundefined\n\nnull\n\nこのうち、それ以上分解できないシンプルなデータを「プリミティブ型」と呼びます。 ここでは、よく出てくるプリミティブ型を紹介します。\n\nboolean リテラル\nboolean型は true/false の2つの真偽値を取るデータ型です。 if 文、while ループなどの制御構文や、三項演算子などを使ってプログラムの挙動をコントロールするために大切な型です。\n\n// 値を表示\nconsole.log(true);\nconsole.log(false);\n\n// 変数に代入。変数の型名はboolean\nconst flag: boolean = true;\n\n// 他のデータ型への変換\nconsole.log(flag.toString()); // 'true' / 'false' になる\nconsole.log(String(flag));    // こちらでも変換可能\nconsole.log(Number(flag));    // 1, 0になる\n\n// 他のデータ型をtrue/falseに変換\nconst notEmpty = Boolean(\"test string\"); // 変換ルールは後述\nconst flag = flagStr === 'true';         // 'true'の文字をtrueにするなら\nconst str = \"not empty string\";          // true/false反転するが演算子一つで変換可能\nconst isEmpty = !str;                    // 反転すると!Boolean()と同じ\nconst notEmpty = !!str;                  // もう1つ使うと反転せずにboolean型に\nTypeScriptでは、数字のゼロ（負も含む）、空文字列、 null 、 undefined 、 NaN を変換すると false 、それ以外を変換すると true になります 1 。\n\n1\nこの真偽値への変換ルールは言語によって異なります。例えば、Pythonでは空の配列や辞書も偽（False ）になります。Rubyの場合は数字のゼロや空文字列も真（true ）になります。\n\nド・モルガンの法則\nif 文の条件式が複雑なときに、それを簡単にするのにごくたまに役立つのがド・モルガンの法則です。 次のような法則でNOTとANDとORの組みを変換できます。\n\nド・モルガンの法則\n!(P || Q) == !P && !Q\n!(P && Q) == !P || !Q\n特に、右辺から左辺への変換がコードの可読性を高めることが多いと思います。 NOTの集合同士の演算というのは普段の生活ではあまり出てきません。 集合のAND/ORを考えてから逆転させる方が簡単にイメージできる思いますので、条件を書く時に、想定が漏れてロジックが正しく動作しない、ということが減るでしょう。 また、より構成要素が多い論理式のときに、式を整理するのにも使えます。\n\n数値型\nTypeScriptには組み込みで2種類の数値型があります。ほとんどの場合は number だけで済むでしょう。\n\nnumber\nTypeScript（というか、その下で動作しているJavaScript）は64ビットの浮動小数点数で扱います。これはどのCPUを使っても基本的に同じ精度を持ちます 2 。整数をロスなく格納できるのは53ビット(-1)までなので、±約9007兆までの整数を扱えます。それ以上の数値を入れると、末尾が誤差としてカットされたりして、整数を期待して扱うと問題が生じる可能性があります。正確な上限と下限は Number.MAX_SAFE_INTEGER 、 Number.MIN_SAFE_INTEGER という定数で見ることができます。また、 Number.isSafeInteger(数値) という関数で、その範囲内に収まっているかどうかを確認できます。\n\n_images/double.png\nThe memory format of an IEEE 754 double floating point value. by Codekaizen (CC 4.0 BY-SA)\n\n2\nIEEE 754という規格で決まっています。\n\n// 値を表示\nconsole.log(10.5);\nconsole.log(128);\nconsole.log(0b11); // 0bから始まると2進数\nconsole.log(0777); // 0, 0oから始まると8進数\nconsole.log(0xf7); // 0xから始まると16進数\n\n// 変数に代入。変数の型名はnumber\nconst year: number = 2019;\n\n// 他のデータ型への変換\nconsole.log(year.toString());  // '2019'になる\nconsole.log(year.toString(2)); // toStringの引数で2進数-36進数にできる\nconsole.log(Boolean(year));    // 0以外はtrue\n\n// 他のデータ型を数値に変換\nconsole.log(parseInt(\"010\"));     // →10 文字列はparseIntで10進数/16進数変換\nconsole.log(parseInt(\"010\", 8));  // →8 2つめの数値で何進数として処理するか決められる\nconsole.log(Number(true));        // boolean型はNumber関数で0/1になる\n変換の処理は、方法によって結果が変わります。10進数を期待するものはradix無しの parseInt() で使っておけば間違いありません。\n\n文字列から数値の変換\nNumber(文字列)\n\nparseInt(文字列)\n\nparseInt(文字列, radix)\n\nリテラル\n\n\"10\"\n\n10\n\n10\n\nradixによって変化\n\n10\n\n\"010\"\n\n10\n\n10\n\nradixによって変化\n\n8 (8進数)\n\n\"0x10\"\n\n16\n\n16\n\nradixが16以外は0\n\n8 (8進数)\n\n\"0o10\"\n\n8\n\n0\n\n0\n\n8 (8進数)\n\n\"0b10\"\n\n2\n\n0\n\n0\n\n2 (8進数)\n\nなお、リテラルの8進数ですが、ESLintの推奨設定を行うと no-octal というオプションが有効になります。このフラグが有効だと、8進数を使用すると警告になります。\n\n注釈\nIE8以前及びその時代のブラウザは、 parseInt() に0が先頭の文字列を渡すと8進数になっているため、かならずradixを省略せずに10を設定しろ、というのが以前言われていました。\n\nその世代のブラウザは現在市場に出回っていないため、10は省略しても問題ありません。\n\n数値型の使い分け\nTypeScriptには組み込みで2種類の数値型があります。 2つの型を混ぜて計算することはできません。\n\nnumber: 64ビットの浮動小数点数\n\nbigint: 桁数制限のない整数（ 10n のように、後ろにnをつける）\n\nnumber 型は多くのケースではベストな選択になります。特に浮動小数点数を使うのであればこちらしかありません。 それ以外に、±2^53-1までであれば整数として表現されるので情報が減ったりはしません。また、これらの範囲では一番高速に演算できます。\n\nbigint 型は整数しか表現できませんが、桁数の制限はありません。ただし、現時点では \"target\": \"esnext\" と設定しないと使えません。 使える場面はかなり限られるでしょう。本ドキュメントでは詳しく扱いません。\n\nnumber は2進数で表した数値表現なので、 0.2 + 0.1などのようなきれいに2進数で表現できない数値は誤差が出てしまいます。金額計算など、多少遅くても正確な計算が必要な場合はdecimal.js 3 などの外部ライブラリを使います。\n\nnumberの誤差\nconst a = 0.1;\nconst b = 0.2;\nconsole.log(a + b);\n// 0.30000000000000004\n3\nhttps://www.npmjs.com/package/decimal.js\n\n演算子\n+ 、 - 、 * 、 / 、 % （剰余）のよくある数値計算用の演算子が使えます。これ以外に、 ** というベキ乗の演算子がES2016で追加されています 4 。\n\nまた、 number は整数としても扱えますのでビット演算も可能です。ビット演算は2進数として表現した表を使って、計算するイメージを持ってもらえると良いでしょう。コンピュータの内部はビット単位での処理になるため、高速なロジックの実装で使われることがよくあります 5 。\n\nただし、ビット演算時には精度は32ビット整数にまで丸められてから行われるため、その点は要注意です。\n\nAND\n\na & b\n\n2つの数値の対応するビットがともに1の場合に1を返します。\n\nOR\n\na | b\n\n2つの数値の対応するビットのどちらかが1の場合に1を返します。\n\nXOR\n\na ^ b\n\n2つの数値の対応するビットのどちらか一方のみが1の場合に1を返します。\n\nNOT\n\n~a\n\nビットを反転させます\n\nLSHIFT\n\na << b\n\naのビットを、b (32未満の整数)分だけ左にずらし、右から0をつめます。\n\nRSHIFT\n\na >> b\n\naのビットを、b (32未満の整数)分だけ右にずらし、左から0をつめます。符号は維持されます。\n\n0埋めRSHIFT\n\na >>> b\n\naのビットを、b (32未満の整数)分だけ右にずらし、左から0をつめます。\n\nなお、トリッキーな方法としては、次のビット演算を利用して、小数値を整数にする方法があります。なぜ整数になるかはぜひ考えて見てください 6 。これらの方法、とくに後者の方は小数値を整数にする最速の方法として知られているため、ちょっと込み入った計算ロジックのコードを読むと出てくるかもしれません。\n\n~~ を先頭につける\n\n|0 を末尾につける\n\n4\n以前は Math.pow(x, y) という関数を使っていました。\n\n5\nビット演算を多用する用途としては、遺伝子情報を高速に計算するのに使うFM-Indexといったアルゴリズムの裏で使われる簡潔データ構造と呼ばれるデータ構造があります。\n\n6\nただし、ビット演算なので、本来扱えるよりもかなり小さい数字でしか正常に動作しません。\n\n特殊な数値\n数値計算の途中で、正常な数値として扱えない数値が出てくることがあります。業務システムでハンドリングすることはあまりないと思います。もし意図せず登場することがあればロジックの不具合の可能性が高いでしょう。\n\n無限大: Infinity\n\n数字ではない: NaN (Not a Number)\n\nMath オブジェクト\nTypeScriptで数値計算を行う場合、 Math オブジェクトの関数や定数を使います。\n\n数値の最大値、最小値\n関数\n\n説明\n\nMath.max(x, y, …)\n\n複数の値の中で最大の値を返す。配列内の数値の最大値を取得したい場合は Math.max(...array)\n\nMath.min(x, y, …)\n\n複数の値の中で最小の値を返す。配列内の数値の最大値を取得したい場合は Math.min(...array)\n\n乱数生成の関数もここに含まれます。0から1未満の数値を返します。例えば0-9の整数が必要な場合は、10倍して Math.floor() などを使うと良いでしょう。\n\n乱数\n関数\n\n説明\n\nMath.random()\n\n0以上1未満の疑似乱数を返す。暗号的乱数が必要な場合は crypto.randomBytes() を代わりに使う。\n\n整数に変換する関数はたくさんあります。一見、似たような関数が複数あります。例えば、 Math.floor() と Math.trunc() は似ていますが、負の値を入れた時に、前者は数値が低くなる方向に（-1.5なら-2）丸めますが、後者は0に近く方向に丸めるといった違いがあります。\n\n整数変換\n関数\n\n説明\n\nMath.abs(x)\n\nxの絶対値を返す。\n\nMath.ceil(x)\n\nx以上の最小の整数を返す。\n\nMath.floor(x)\n\nx以下の最大の整数を返す。\n\nMath.fround(x)\n\nxに近似の単精度浮動小数点数を返す。ES2015以上。\n\nMath.round(x)\n\nxを四捨五入して、近似の整数を返す。\n\nMath.sign(x)\n\nxが正なら1、負なら-1、0なら0を返す。ES2015以上。\n\nMath.trunc(x)\n\nxの小数点以下を切り捨てた値を返す。ES2015以上。\n\n整数演算の補助関数もいくつかあります。ビット演算と一緒に使うことが多いと思われます。\n\n32ビット整数\n関数\n\n説明\n\nMath.clz32(x)\n\nxを2進数32ビット整数値で表した数の先頭の0の個数を返す。ES2015以上。\n\nMath.imul(x, y)\n\n32ビット同士の整数の乗算の結果を返す。超えた範囲は切り捨てられる。主にビット演算と一緒に使う。ES2015以上。\n\n平方根などに関する関数もあります。\n\nルート\n関数・定数\n\n説明\n\nMath.SQRT1_2\n\n1/2の平方根の定数。\n\nMath.SQRT2\n\n2の平方根の定数。\n\nMath.cbrt(x)\n\nxの立方根を返す。ES2015以上。\n\nMath.hypot(x, y, …)\n\n引数の数値の二乗和の平方根を返す。ES2015以上。\n\nMath.sqrt(x)\n\nxの平方根を返す。\n\n対数関係の関数です。\n\n対数\n関数・定数\n\n説明\n\nMath.E\n\n自然対数の底（ネイピア数）を表す定数。\n\nMath.LN10\n\n10の自然対数を表す定数。\n\nMath.LN2\n\n2の自然対数を表す定数。\n\nMath.LOG10E\n\n10を底としたeの対数を表す定数。\n\nMath.LOG2E\n\n2を底としたeの対数を表す定数。\n\nMath.exp(x)\n\nMath.E ** x を返す。\n\nMath.expm1(x)\n\nexp(x) から1を引いた値を返す。ES2015以上。\n\nMath.log(x)\n\nxの自然対数を返す。\n\nMath.log1p(x)\n\n1 + x の自然対数を返す。ES2015以上。\n\nMath.log10(x)\n\nxの10を底とした対数を返す。ES2015以上。\n\nMath.log2(x)\n\nxの2を底とした対数を返す。ES2015以上。\n\n最後は円周率や三角関数です。引数や返り値で角度を取るものはすべてラジアンですので、度 （°）で数値を持っている場合は * Math.PI / 180 でラジアンに変換してください。\n\nstring リテラル\nstring リテラルは文字列を表現します。シングルクオート、ダブルクオートでくくると表現できます。 シングルクオートとダブルクオートは、途中で改行が挟まると「末尾がない」とエラーになってしまいますが、 バッククオートでくくると、改行が中にあっても大丈夫なので、複数行あるテキストをそのまま表現できます。\n\n// 値を表示\n// シングルクオート、ダブルクオート、バッククオートでくくる\nconsole.log('hello world');\n\n// 変数に代入。変数の型名はboolean\nconst name: string = \"future\";\n\n// 複数行\n// シングルクオート、ダブルクオートだとエラーになる\n// error TS1002: Unterminated string literal.\nconst address = '東京都\n品川区';\n// バッククオートならOK。ソースコード上の改行はデータ上も改行となる\nconst address = `東京都\n品川区`;\n\n// 他のデータ型への変換\nconsole.log(parseInt('0100', 10)); // 100になる\nconsole.log(Boolean(name));        // 空文字列はfalse、それ以外はtrueになる\n\n// 他のデータ型をstringに変換\nconst year = 2019;\nconsole.log((2019).toString(2));     // numberはtoStringの引数で2進数-36進数にできる\nconsole.log((true).toString());      // boolean型を'true'/'false'の文字列に変換\nconsole.log(Stirng(false));          // こちらでも可\nJavaScriptはUTF-16という文字コードを採用しています。Javaと同じです。絵文字など、一部の文字列は1文字分のデータでは再現できずに、2文字使って1文字を表現することがあります。これをサロゲートペアと呼びます。範囲アクセスなどで文字列の一部を扱おうとすると、絵文字の一部だけを拾ってしまう可能性がある点には要注意です。何かしらの文字列のロジックのテストをする場合には、絵文字も入れるようにすると良いでしょう。\n\n文字列のメソッド\n文字列には、その内部で持っている文字列を加工したり、一部を取り出したりするメソッドがいくつもあります。 かなり古いJavaScriptの紹介だと、HTMLタグをつけるためのメソッドが紹介されていたりもします、TypeScriptの型定義ファイルにも未だに存在はしますが、それらのメソッドは言語標準ではないためここでは説明しません。\n\n文字コードの正規化\nユニコードには、同じ意味だけどコードポイントが異なり、字形が似ているけど少し異なる文字というものが存在します。たとえば、全角のアルファベットのＡと、半角アルファベットのAがこれにあたります。 それらを統一してきれいにするのが正規化です。文字列の normalize(\"NFKC\") というメソッド呼び出しをすると、これがすべてきれいになります。\n\n> \"ＡＢＣｱｲｳｴｵ㍻\".normalize(\"NFKC\")\n'ABCアイウエオ平成'\n正規化を行わないと、例えば、「６月６日議事録.md」という全角数字のファイル名を検索しようとして、「6月6日議事録」という検索ワードで検索しようとしたときにひっかからない、ということがおきます。検索対象と検索ワードの両方を正規化しておけば、このような表記のブレがなくなるため、ひっかかりそうでひっかからない、ということが減らせます。\n\n正規形は次の4通りあります。Kがついているものがこのきれいにする方です。また、Dというのは、濁音の記号とベースの文字を分割するときの方法、Cは結合するときの方法になります。macOSの文字コードがNFKDなので、たまにmacOSのChromeでGoogle Spreadsheetを使うと、コピペだかなんだかのタイミングでこのカタカナの濁音が2文字に分割された文字列が挿入されることがあります。 NFKC をつかっておけば問題はないでしょう。\n\nNFC\n\nNFD\n\nNFKC\n\nNFKD\n\n正規化をこのルールに従って行うと、ユーザーに「全角数字で入力する」ことを強いるような、かっこ悪いUIをなくすことができます。ユーザーの入力はすべてバリデーションの手前で正規化すると良いでしょう。\n\nただし、長音、ハイフンとマイナス、漢数字の１、横罫線など、字形が似ているものの意味としても違うものはこの正規化でも歯が立たないので、別途対処が必要です。\n\n文字列の結合\n従来のJavaScriptは他の言語でいうprintf系の関数がなく、文字列を+で結合したり、配列に入れて.join()で結合したりしましたが、いまどきは文字列テンプレートリテラルがありますので、ちょっとした結合は簡単に扱えます。 printfのような数値の変換などのフォーマットはなく、あくまでも文字列結合をスマートにやるためのものですが、複数行のテキストを表現できますし、プレースホルダ内には自由に式が書けます。 もちろん、数が決まらない配列などは従来どおり.join()を使います。\n\n// 古いコード\nconsole.log(\"[Debug]:\" + variable);\n\n// 新しいコード\nconsole.log(`[Debug]: ${variable}`);\nこのバッククオートを使う場合は、関数を前置することで、文字列を加工することができます。 国際化でメッセージを置き換える場面などで利用されます。\n\n文字列の事前処理\nテンプレートリテラルに関数を指定すると（タグ付きテンプレートリテラル）、文字列を加工する処理を挟めます。よく使われるケースは翻訳などでしょう。 テンプレートリテラルの前に置かれた関数は、最初に文字列の配列がきて、その後はプレースホルダの数だけ引数が付く構造になっています。 文字列の配列は、プレースホルダに挟まれた部分のテキストになります。 自作する機会は多くないかもしれませんが、コード理解のために覚えておいて損はないでしょう。\n\nタグ付きテンプレートリテラル\nfunction i18n(texts, ...placeholders) {\n  // texts = ['小動物は', 'が好きです']\n  // placeholders = ['小旅行']\n  return // 翻訳処理\n}\n\nconst hobby = \"小旅行\"\nconsole.log(i18n`小動物は${hobby}が好きです`);\nundefined と null\nJavaScript/TypeScriptでは、 undefined と null があります。他の言語では null （もしくは None 、 nil と呼ぶことも）だけの場合がほとんどですが、JavaScript/TypeScriptでは2種類登場します。\n\nこのうち、 undefined は未定義やまだ値が代入されていない変数を参照したり、オブジェクトの未定義の属性に触ると帰ってくる値です。 TypeScriptはクラスなどで型定義を行い、コーディングがしやすくなるとよく宣伝されますが、「 undefined に遭遇するとわかっているコードを事前にチェックしてくれる」ということがその本質だと思われます。\n\nlet favoriteGame: string; // まだ代入してないのでundefined;\nconsole.log(favoriteGame);\nこのコードは、 tsconfig.json で strict: true （もしくは strictNullChecks: true ）の場合にはコンパイルエラーになります。\n\nJavaScriptはメソッドや関数呼び出し時に数が合わなくてもエラーにはならず、指定されなかった引数には undefined が入っていました。 TypeScriptでは数が合わないとエラーになりますが、 ? を変数名の最後に付与すると、省略可能になります。\n\nfunction print(name: string, age?: number) {\n    console.log(`name: ${name}, age: ${age || 'empty'}`);\n}\n意図せずうっかりな「未定義」が undefined であれば、意図をもって「これは無効な値だ」と設定するのが null です。 ただし、Javaと違って、気軽に null を入れることはできません。共用体（union）型定義という、「AもしくはB」という型宣言ができるので、これをつかって null を代入します。 TypeScriptでは「これは無効な値をとる可能性がありますよ」というのは意識して許可してあげなければなりません。\n\n// stringかnullを入れられるという宣言をしてnullを入れる\nlet favaoriteGame: string | null = null;\nundefined と null は別のものなので、コンパイラオプションで compilerOptions.strict: true もしくは、 compilerOptions.strictNullChecks: true の場合は、 null 型の変数に undefined を入れようとしたり、その逆をするとエラーになります。 これらのオプションを両方とも false にすれば、エラーにはならなくなりますが、副作用が大きいため、これらのオプションは有効にして、普段から正しくコードを書く方が健全です。\n\nnullとundefinedは別物\nconst a: string | null = undefined;\n// error TS2322: Type 'undefined' is not assignable to type 'string | null'.\n\nconst b: string | undefined = null;\n// error TS2322: Type 'null' is not assignable to type 'string | undefined'.\nまとめ\nTypeScript（とJavaScript）で登場する、プリミティブ型を紹介してきました。 これらはプログラムを構成する上でのネジやクギとなるデータです。"
}